// Generated by CoffeeScript 2.4.1
(function() {
  var $, _, _selectors, addSelectors, addStyle, baseSelectors, colors, curry, defaultColors, defaultUnit, extractMediaQueries, fromPairs, getBaseStyleMaps, head, identity, isNil, keys, last, map, match, matchG, max, merge, min, nth, qq, qqq, replace, setOrAppend, shortstyle, split, test, toPairs, trim, tryParseNum, type, untangle;

  curry = require('ramda/src/curry');

  fromPairs = require('ramda/src/fromPairs');

  head = require('ramda/src/head');

  identity = require('ramda/src/identity');

  isNil = require('ramda/src/isNil');

  keys = require('ramda/src/keys');

  last = require('ramda/src/last');

  map = require('ramda/src/map');

  match = require('ramda/src/match');

  max = require('ramda/src/max');

  merge = require('ramda/src/merge');

  min = require('ramda/src/min');

  nth = require('ramda/src/nth');

  replace = require('ramda/src/replace');

  split = require('ramda/src/split');

  test = require('ramda/src/test');

  toPairs = require('ramda/src/toPairs');

  trim = require('ramda/src/trim');

  type = require('ramda/src/type');

  ({$} = require('ramda-extras')); //auto_require: ramda-extras
  //auto_sugar

  [];

  // $ = (data, functions...) -> pipe(functions...)(data)
  qq = function(f) {
    return console.log(match(/return (.*);/, f.toString())[1], f());
  };

  qqq = function(...args) {
    return console.log(...args);
  };

  _ = function(...xs) {
    return xs;
  };

  getBaseStyleMaps = require('./baseStyleMaps');

  colors = require('./colors');

  tryParseNum = function(x) {
    if (isNaN(x)) {
      return x;
    } else {
      return Number(x);
    }
  };

  _selectors = {
    f: ':first-child',
    l: ':last-child',
    e: ':nth-child(even)',
    o: ':nth-child(odd)',
    // https://css-tricks.com/solving-sticky-hover-states-with-media-hover-hover/
    // https://stackoverflow.com/questions/23885255/how-to-remove-ignore-hover-css-style-on-touch-devices
    ho: {
      '@media (hover: hover)': ':hover'
    },
    fo: ':focus',
    '2l': ':nth-last-child(2)',
    fin: {
      '@media (pointer: fine)': ''
    },
    coa: {
      '@media (pointer: coarse)': ''
    },
    ac: ':active'
  };

  baseSelectors = $(_selectors, toPairs, map(function([k, v]) {
    return ['n' + k, `:not(${v})`];
  }), fromPairs, merge(_selectors));

  baseSelectors.hofo = [
    {
      '@media (hover: hover)': ':hover'
    },
    ':focus'
  ];

  // R.match(/(\w)(\d)/g, 'a1 b2 c3') returns ["a1", "b2", "c3"]
  // matchG(/(\w)(\d)/g, 'a1 b2 c3') returns [["a1", "a", "1"], ["b2", "b", "2"], ["c3", "c", "3"]]
  // ie. matchG includes the capturing groups for each match which R.match does not do when g-flag is used
  // similar to how m.forEach((match, groupIndex) => ..) works with regex.exec in "raw" javascript, eg:
  // Ex. https://regex101.com/r/CjwqtE/1
  // https://regex101.com/r/CjwqtE/1/codegen?language=javascript
  // https://ramdajs.com/repl/?v=0.26.1#?R.match%28%2F%28%5Cw%29%28%5Cd%29%2Fg%2C%20%27a1%20b2%20c3%27%29
  matchG = curry(function(re, str) {
    var lastGroupIndex, m, reG, res;
    res = [];
    reG = new RegExp(re.source, re.flags + test(/g/, re.flags) && '' || 'g');
    while ((m = reG.exec(str)) !== null) {
      // This is necessary to avoid infinite loops with zero-width matches
      if (m.index === reG.lastIndex) {
        reG.lastIndex++;
      }
      // The result can be accessed through the `m`-variable.
      lastGroupIndex = 999;
      m.forEach(function(match, groupIndex) {
        if (groupIndex < lastGroupIndex) {
          res.push([]);
        }
        res[res.length - 1].push(match);
        return lastGroupIndex = groupIndex;
      });
    }
    return res;
  });

  // eg. '<100[m1] p2' => {'': 'p2', '@media (max-width: 100px)': 'm1'}
  extractMediaQueries = function(str) {
    var REmedia, ___, body, gt_lt, j, len, m, media, ms, size;
    REmedia = /([<>])(\d+)\[(.*?)\]\s?/g;
    ms = matchG(REmedia, str);
    media = {};
    for (j = 0, len = ms.length; j < len; j++) {
      m = ms[j];
      [___, gt_lt, size, body] = m;
      media[`@media (${gt_lt === '<' && 'max' || 'min'}-width: ${size}px)`] = body;
    }
    media[''] = $(str, replace(REmedia, ''), trim);
    return media;
  };

  // Recursively flattens values for the empty key ''
  // eg. {a: {'': {a1: 'x'}, a2: 'y'}, '': {b1: 'z'}}
  // returns {a: {a1: 'x', a2: 'y'}, b1: 'z'}
  untangle = function(o) {
    var k, res, v;
    if (type(o) !== 'Object') {
      return o;
    }
    res = {};
    for (k in o) {
      v = o[k];
      if (k === '') {
        Object.assign(res, untangle(v));
      } else {
        res[k] = untangle(v);
      }
    }
    return res;
  };

  // Unpure helper that sets or merges value x onto o[k]
  setOrAppend = function(k, x, o) {
    if (!o[k]) {
      return o[k] = x;
    } else {
      if (type(x) === 'String') {
        return o[k] += ' ' + x;
      } else if (type(x) === 'Object') {
        return o[k] = merge(o[k], x);
      }
    }
  };

  addSelectors = function(allSelectors, o) {
    var REsels, ___, body, j, k, l, len, len1, m, media, ms, res, sel, selector, v, x;
    REsels = /(\w+)\((.*?)\)\s?/g;
    res = {};
    for (k in o) {
      v = o[k];
      if (type(v) !== 'String') {
        throw new Error('NYI'); // could easily support more nesting of @medias though
      }
      ms = matchG(REsels, v);
      res[k] = {
        '': $(v, replace(REsels, ''), trim)
      };
      for (j = 0, len = ms.length; j < len; j++) {
        m = ms[j];
        [___, sel, body] = m;
        selector = allSelectors[sel];
        if (!selector) {
          console.warn(`invalid selector: ${sel}`);
        } else if (type(selector) === 'Array') {
          for (l = 0, len1 = selector.length; l < len1; l++) {
            x = selector[l];
            if (type(x) === 'String') {
              setOrAppend(x, body, res[k]);
            } else if (type(x) === 'Object') {
              media = $(x, keys, head);
              setOrAppend(media, {
                [`${x[media]}`]: body
              }, res[k]);
            } else {
              throw new Error('NYI');
            }
          }
        } else if (type(selector) === 'Object') {
          media = $(selector, keys, head);
          setOrAppend(media, {
            [`${selector[media]}`]: body
          }, res[k]);
        } else if (type(selector) === 'String') {
          setOrAppend(selector, body, res[k]);
        } else {
          throw new Error(`NYI selector type ${type(selector)}`);
        }
      }
    }
    return res;
  };

  addStyle = function(allStyleMaps, o) {
    var i, j, k, key, l, len, ref, res, s, si, ss, style, v, val;
    res = {};
    for (key in o) {
      v = o[key];
      switch (type(v)) {
        case 'Object':
          res[key] = addStyle(allStyleMaps, v);
          break;
        case 'String':
          ss = split(' ', v);
          style = {};
          for (j = 0, len = ss.length; j < len; j++) {
            s = ss[j];
            if (s === '' || s === 'false' || s === 'true' || s === 'undefined' || s === 'null') {
              continue;
            }
            for (i = l = ref = s.length; (ref <= 0 ? l < 0 : l > 0); i = ref <= 0 ? ++l : --l) {
              si = s.substr(0, i);
              if (allStyleMaps[si]) {
                k = si;
                break;
              }
            }
            if (!k) {
              console.warn(`invalid shortstyle: ${s}`);
              res[key] = {};
              continue;
            }
            v = s.substr(k.length); // eg. top5 -> 5
            val = $(v, allStyleMaps[k].refine || identity, tryParseNum);
            Object.assign(style, allStyleMaps[k](val, style));
          }
          res[key] = style;
          break;
        default:
          throw new Error("NYI");
      }
    }
    return res;
  };

  defaultUnit = function(x, base = 0) {
    var RE, RE2, ___, extra, neg, num, num_, vhvw, x_;
    if (type(x) === 'Number') {
      return (x + base) / 10 + 'rem';
    } else if (!isNaN(x)) { // we allow numbers as strings to eg. '2' so we can be a bit lazy in parsing
      x_ = parseFloat(x);
      return (x_ + base) / 10 + 'rem';
    } else {
      RE = /^(-)?(\d+)\+(\d+)(vh|vw)?$/;
      RE2 = /^(-?\d+)x$/;
      if (test(RE, x)) {
        [___, neg, num_, extra, vhvw] = match(RE, x);
        num = parseInt(num_) + base;
        return `calc(${neg && '-1 * ' || ''}(${num / 10}rem + ${extra * 5 / 10}${vhvw || 'vw'}))`;
      }
      if (test(RE2, x)) { // P책 test... k채nns inte som det 채r anv채ndbart
        [___, extra] = match(RE2, x);
        return parseInt(extra) * 5 / 10 + 'vh';
      } else {
        return x;
      }
    }
  };

  defaultColors = colors.buildColors({
    wh: [0, 0, 100],
    bk: [0, 0, 0],
    gn: [177, 51, 35],
    ye: [52, 58, 99]
  });

  // Takes styleMaps and unit function and returns parse and createElementHelper
  shortstyle = function({styleMaps = {}, unit = defaultUnit, colors = defaultColors, selectors = {}}) {
    var allSelectors, allStyleMaps, baseStyleMaps, memo;
    baseStyleMaps = getBaseStyleMaps(unit, colors);
    allStyleMaps = merge(baseStyleMaps, styleMaps);
    allSelectors = merge(baseSelectors, selectors);
    memo = {};
    return function(str) {
      var style1, style2, style3, style4;
      if (isNil(str)) {
        return {};
      }
      if (memo[str]) {
        return memo[str];
      }
      // 'm2 <200[m1 f(p2)]'
      style1 = extractMediaQueries(str);
      // {'': 'm2', '@media (min-width: 200px)': 'm1 f(p2)'}
      style2 = addSelectors(allSelectors, style1);
      // {'': {'': 'm2'}, '@media (min-width: 200px)': {'': 'm1', ':first-child': 'p2'}}
      style3 = addStyle(allStyleMaps, style2);
      // {'': {'': {margin: 2}}, '@media (min-width: 200px)': {'': {margin: 1}, ':first-child': {padding: 2}}}
      style4 = untangle(style3);
      // {margin: 2, '@media (min-width: 200px)': {margin: 1, ':first-child': {padding: 2}}}
      memo[str] = style4;
      return style4;
    };
  };

  shortstyle.colors = colors;

  shortstyle.defaultUnit = defaultUnit;

  module.exports = shortstyle;

}).call(this);
